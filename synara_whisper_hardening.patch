diff --git a/backend/config.py b/backend/config.py
new file mode 100644
index 0000000..9b8f0f1
--- /dev/null
+++ b/backend/config.py
@@ -0,0 +1,33 @@
+import os
+
+# Feature flags
+WHISPER_HARDENING_ENABLED = os.getenv("WHISPER_HARDENING_ENABLED", "1") == "1"
+
+# Traffic shaping (timing jitter in ms) + body padding (bytes)
+PAD_MIN_MS = int(os.getenv("PAD_MIN_MS", "80"))
+PAD_MAX_MS = int(os.getenv("PAD_MAX_MS", "220"))
+PAD_MIN_BYTES = int(os.getenv("PAD_MIN_BYTES", "512"))
+PAD_MAX_BYTES = int(os.getenv("PAD_MAX_BYTES", "2048"))
+
+# Token bucket RL (fallback if Redis not present)
+RL_BUCKET_CAP = int(os.getenv("RL_BUCKET_CAP", "60"))
+RL_REFILL_PER_SEC = float(os.getenv("RL_REFILL_PER_SEC", "1.0"))
+
+# Redis URL (nonce/ratelimit optional)
+REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
+
+# Compression off (reduce size/timing side-channels)
+DISABLE_COMPRESSION_PATHS = [
+    "/verify", "/challenge",
+    "/codex/share", "/codex/delegate",
+    "/codex/resonance_share", "/codex/resonance_share/v2",
+]
diff --git a/backend/security/util.py b/backend/security/util.py
new file mode 100644
index 0000000..a2a2a2a
--- /dev/null
+++ b/backend/security/util.py
@@ -0,0 +1,9 @@
+def pad_bytes(data: bytes, min_pad: int) -> bytes:
+    """
+    Pad response bodies to blunt size-correlation leaks.
+    We append zero bytes plus a 1-byte marker to defeat gzip savings.
+    """
+    if not isinstance(data, (bytes, bytearray)):
+        data = str(data).encode("utf-8")
+    return data + b"\x00" * min_pad + b"\x01"
+
diff --git a/backend/security/stream_shield.py b/backend/security/stream_shield.py
new file mode 100644
index 0000000..b1b1b1b
--- /dev/null
+++ b/backend/security/stream_shield.py
@@ -0,0 +1,54 @@
+import random
+from starlette.middleware.base import BaseHTTPMiddleware
+from starlette.responses import Response
+from backend.config import (
+    PAD_MIN_MS, PAD_MAX_MS, PAD_MIN_BYTES, PAD_MAX_BYTES, DISABLE_COMPRESSION_PATHS
+)
+from .util import pad_bytes
+
+async def _sleep_ms(ms: int):
+    import asyncio
+    await asyncio.sleep(ms / 1000.0)
+
+class StreamShieldMiddleware(BaseHTTPMiddleware):
+    """
+    Adds jittered latency + size padding on sensitive routes to blunt traffic analysis.
+    Also forces identity (no compression) on those routes.
+    """
+    async def dispatch(self, request, call_next):
+        path = request.url.path
+
+        # strip client compression hints; we force identity later
+        if path in DISABLE_COMPRESSION_PATHS:
+            request.scope["headers"] = tuple(
+                (k, v) for (k, v) in request.scope.get("headers", [])
+                if k.lower() != b"accept-encoding"
+            )
+
+        resp = await call_next(request)
+
+        if path not in DISABLE_COMPRESSION_PATHS:
+            return resp
+
+        # Force no compression
+        resp.headers["Content-Encoding"] = "identity"
+        resp.headers["X-Compression-Blocked"] = "1"
+        resp.headers["Cache-Control"] = "no-store"
+
+        # Jitter timing
+        delay_ms = random.randint(PAD_MIN_MS, PAD_MAX_MS)
+        await _sleep_ms(delay_ms)
+
+        # Pad body
+        raw = await resp.body()
+        pad_len = random.randint(PAD_MIN_BYTES, PAD_MAX_BYTES)
+        padded = pad_bytes(raw, pad_len)
+
+        new_resp = Response(
+            content=padded,
+            status_code=resp.status_code,
+            headers=dict(resp.headers),
+            media_type=resp.media_type or "application/octet-stream",
+        )
+        new_resp.headers["X-Pad-Latency-Ms"] = str(delay_ms)
+        new_resp.headers["X-Pad-Bytes"] = str(pad_len)
+        return new_resp
diff --git a/backend/security/ratelimit.py b/backend/security/ratelimit.py
new file mode 100644
index 0000000..c3c3c3c
--- /dev/null
+++ b/backend/security/ratelimit.py
@@ -0,0 +1,56 @@
+import time, threading
+from typing import Dict
+from backend.config import RL_BUCKET_CAP, RL_REFILL_PER_SEC, REDIS_URL
+
+_USE_REDIS = False
+_store: Dict[tuple, Dict[str, float]] = {}
+_lock = threading.Lock()
+
+try:
+    import redis
+    _r = redis.Redis.from_url(REDIS_URL, decode_responses=True)
+    _r.ping()
+    _USE_REDIS = True
+except Exception:
+    _USE_REDIS = False
+
+def _k(ip: str, route: str) -> str:
+    return f"rl:{route}:{ip}"
+
+def allow(ip: str, route: str) -> bool:
+    now = time.time()
+    if _USE_REDIS:
+        k = _k(ip, route)
+        rec = _r.hgetall(k) or {}
+        tokens = float(rec.get("t", RL_BUCKET_CAP))
+        last = float(rec.get("ts", now))
+        tokens = min(RL_BUCKET_CAP, tokens + (now - last) * RL_REFILL_PER_SEC)
+        if tokens < 1.0:
+            _r.hset(k, mapping={"t": tokens, "ts": now}); _r.expire(k, 3600)
+            return False
+        tokens -= 1.0
+        _r.hset(k, mapping={"t": tokens, "ts": now}); _r.expire(k, 3600)
+        return True
+
+    with _lock:
+        rec = _store.get((ip, route), {"t": RL_BUCKET_CAP, "ts": now})
+        tokens = min(RL_BUCKET_CAP, rec["t"] + (now - rec["ts"]) * RL_REFILL_PER_SEC)
+        if tokens < 1.0:
+            _store[(ip, route)] = {"t": tokens, "ts": now}
+            return False
+        tokens -= 1.0
+        _store[(ip, route)] = {"t": tokens, "ts": now}
+        return True
diff --git a/synara_core/security/whisper_hardening.py b/synara_core/security/whisper_hardening.py
new file mode 100644
index 0000000..d4d4d4d
--- /dev/null
+++ b/synara_core/security/whisper_hardening.py
@@ -0,0 +1,22 @@
+"""
+Hardening helpers for Synara Whisper Handshake (not OpenAI Whisper speech model).
+"""
+import hmac, hashlib, unicodedata
+from typing import Dict
+
+def nfc(s: str) -> str:
+    return unicodedata.normalize("NFC", s)
+
+def canonical_fields(d: Dict) -> Dict:
+    out = {}
+    for k, v in d.items():
+        out[k] = nfc(v) if isinstance(v, str) else v
+    return out
+
+def sign_hmac_ct(key: bytes, msg: str) -> str:
+    # constant-time HMAC-SHA256 (hex)
+    return hmac.new(key, msg.encode("utf-8"), hashlib.sha256).hexdigest()
+
+def compare_ct(a: str, b: str) -> bool:
+    try:
+        return hmac.compare_digest(a, b)
+    except Exception:
+        return False
diff --git a/synara_core/modules/handshake/service.py b/synara_core/modules/handshake/service.py
index 1111111..2222222 100644
--- a/synara_core/modules/handshake/service.py
+++ b/synara_core/modules/handshake/service.py
@@ -1,22 +1,39 @@
-# Tiny FastAPI service exposing challenge + verify using v1.3 core
-# pip install fastapi uvicorn pydantic
+# Tiny FastAPI service exposing challenge + verify using v1.3 core
+# Hardened against timing/size side-channels; adds rate limiting.
 
-from fastapi import FastAPI, HTTPException, Request
+from fastapi import FastAPI, HTTPException, Request
 from fastapi.middleware.cors import CORSMiddleware
 from pydantic import BaseModel
 from typing import Optional, Dict
 
 from .whisper_handshake_v13 import (
     server_mk_challenge,
     server_verify,
     to_compact_json,
     VERSION,
     DRIFT_MS,
 )
 
 from .nonce_store_redis import nonce_seen
@@
 import synara_core.modules.handshake.whisper_handshake_v13 as core
 def _nonce_seen_redis(nonce: str, key_id: str) -> bool:
     return nonce_seen(f"{key_id}:{nonce}", ttl_ms=DRIFT_MS + 500)
 core._nonce_seen = _nonce_seen_redis
 
 app = FastAPI(title="Whisper Synara Handshake", version=VERSION)
 
+# --- Hardening: traffic shaping + rate limiting ---
+from backend.config import WHISPER_HARDENING_ENABLED
+from backend.security.stream_shield import StreamShieldMiddleware
+from backend.security.ratelimit import allow
+
+if WHISPER_HARDENING_ENABLED:
+    app.add_middleware(StreamShieldMiddleware)
+
 # Optional CORS (lock this down in prod)
 app.add_middleware(
     CORSMiddleware,
     allow_origins=["*"],  # set to your app origins in prod
     allow_credentials=False,
     allow_methods=["GET", "POST"],
     allow_headers=["content-type"],
 )
@@
 class VerifyRequest(BaseModel):
     receipt: Dict
     expected_challenge: Optional[str] = None
 
 @app.get("/health")
 def health():
     return {"ok": True, "version": VERSION}
 
 @app.get("/challenge")
-def challenge(prefix: str = "whisper"):
+def challenge(prefix: str = "whisper", request: Request = None):
+    ip = request.client.host if request and request.client else "unknown"
+    if not allow(ip, "/challenge"):
+        raise HTTPException(status_code=429, detail="rate_limited")
     chal = server_mk_challenge(prefix=prefix)
     return {"challenge": chal, "version": VERSION}
 
 @app.post("/verify")
-async def verify(req: VerifyRequest, request: Request):
+async def verify(req: VerifyRequest, request: Request):
+    ip = request.client.host if request and request.client else "unknown"
+    if not allow(ip, "/verify"):
+        raise HTTPException(status_code=429, detail="rate_limited")
     # Simple body-size guard (adjust as needed)
     if request.headers.get("content-length"):
         if int(request.headers["content-length"]) > 4096:
             raise HTTPException(status_code=413, detail="Payload too large")
 
     ok, reason = server_verify(req.receipt, expected_challenge=req.expected_challenge)
     if not ok:
         # Use 401 Unauthorized for failed verification
         raise HTTPException(status_code=401, detail=reason)
 
     # Minimal echo back; avoid reflecting secrets
     return {
         "status": "ok",
         "version": VERSION,
         "reason": reason,  # e.g., "OK"
         "kid": str(req.receipt.get("key_id", "")),
         "aud": str(req.receipt.get("aud", "-")),
         "scope": str(req.receipt.get("scope", "-")),
         # If you really want the compact receipt for QR logging, keep it:
         "receipt_compact": to_compact_json({
             k: v for k, v in req.receipt.items() if k not in ("sig",)
         }),
     }
diff --git a/tests/test_sidechannel_shape.py b/tests/test_sidechannel_shape.py
new file mode 100644
index 0000000..e5e5e5e
--- /dev/null
+++ b/tests/test_sidechannel_shape.py
@@ -0,0 +1,29 @@
+import time, httpx
+
+BASE = "http://localhost:8080"
+
+def _hit(n=8, path="/verify", payload=None):
+    sizes, durs = [], []
+    for _ in range(n):
+        t0 = time.perf_counter()
+        r = httpx.post(f"{BASE}{path}", json=payload or {"receipt": {"x":"y"}})
+        dt = (time.perf_counter() - t0) * 1000
+        sizes.append(len(r.content))
+        durs.append(dt)
+    return sizes, durs
+
+def test_verify_has_padding_and_jitter():
+    sizes, durs = _hit()
+    # Body should be padded into a narrow band (<= ~2KB variance by default)
+    assert (max(sizes) - min(sizes)) <= 2200
+    # Latency should include our minimum jitter (~80ms default)
+    assert min(durs) >= 70.0
diff --git a/helm/synara/values.yaml b/helm/synara/values.yaml
new file mode 100644
index 0000000..abc1234
--- /dev/null
+++ b/helm/synara/values.yaml
@@ -0,0 +1,15 @@
+env:
+  WHISPER_HARDENING_ENABLED: "1"
+  PAD_MIN_MS: "80"
+  PAD_MAX_MS: "220"
+  PAD_MIN_BYTES: "512"
+  PAD_MAX_BYTES: "2048"
+  RL_BUCKET_CAP: "60"
+  RL_REFILL_PER_SEC: "1.0"
+  REDIS_URL: "redis://redis:6379/0"
+
+# If you control NGINX ingress, ensure gzip is off on sensitive paths.
+# Example (Ingress/Nginx annotations):
+# nginx.ingress.kubernetes.io/enable-modsecurity: "false"
+# nginx.ingress.kubernetes.io/proxy-buffering: "on"
+# nginx.ingress.kubernetes.io/proxy-buffer-size: "16k"
diff --git a/requirements.txt b/requirements.txt
index 7c7c7c7..7c7c7c8 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,3 +1,7 @@
 fastapi
 uvicorn
 pydantic
+httpx
+redis