import dash
from dash import dcc, html
from dash.dependencies import Input, Output, State
import pandas as pd
import numpy as np
import plotly.graph_objs as go
import time, json, os
from datetime import datetime

# --- Constants ---
PI_STAR = np.pi ** 0.5
TARGET_RECOVERY = 1.0
INITIAL_SUPPRESSION = 0.2
LOG_PATH = "data/scheduler_state_log.json"
STABILITY_LOG_PATH = "data/stability_log.json"
MAX_HISTORY = 500  # per chunk

# --- Dash init ---
app = dash.Dash(__name__)

# --- Ï€*-recovery model ---
def compute_pi_star_recovery(t, decay_rate):
    return TARGET_RECOVERY - (TARGET_RECOVERY - INITIAL_SUPPRESSION) * np.exp(-decay_rate * np.sqrt(PI_STAR) * t)

# --- Data I/O ---
def load_scheduler_data():
    if not os.path.exists(LOG_PATH):
        return pd.DataFrame(columns=["chunk_id", "timestamp", "latency_ms", "score", "state"])
    with open(LOG_PATH, "r") as f:
        data = json.load(f)
    return pd.DataFrame(data)

def load_stability_log():
    if os.path.exists(STABILITY_LOG_PATH):
        with open(STABILITY_LOG_PATH, "r") as f:
            return json.load(f)
    return {}

def save_stability_log(log):
    os.makedirs(os.path.dirname(STABILITY_LOG_PATH), exist_ok=True)
    with open(STABILITY_LOG_PATH, "w") as f:
        json.dump(log, f, indent=2)

def classify_stability(deviation):
    if deviation < 0.05:
        return "Stable ðŸŸ¢"
    elif deviation < 0.15:
        return "Adjusting ðŸŸ "
    else:
        return "Unstable ðŸ”´"

# --- Dash layout ---
app.layout = html.Div([
    html.H2("Synara Ï€*-Damped Recovery Stability Monitor v3"),
    
    dcc.Dropdown(id='chunk-select', placeholder='Select Chunk ID', style={'width': '60%', 'marginBottom': '15px'}),
    
    html.Div(id='stability-status', style={'fontSize': '22px', 'marginBottom': '10px', 'fontWeight': 'bold'}),
    
    dcc.Graph(id='recovery-graph'),
    dcc.Graph(id='trend-graph'),

    html.Button('Export Stability Log (CSV)', id='export-btn', n_clicks=0, style={'marginTop': '10px'}),
    dcc.Download(id='download-log'),

    dcc.Slider(
        id='decay-slider', min=0.05, max=0.3, step=0.01, value=0.12,
        marks={0.05:'0.05', 0.15:'0.15', 0.25:'0.25', 0.3:'0.3'},
        tooltip={"placement": "bottom", "always_visible": True}
    ),
    
    dcc.Interval(id='refresh-interval', interval=4000, n_intervals=0)
], style={'backgroundColor': '#111', 'color': 'white', 'padding': '20px'})

# --- Update chunk list ---
@app.callback(Output('chunk-select', 'options'), Input('refresh-interval', 'n_intervals'))
def update_chunk_list(_):
    df = load_scheduler_data()
    chunks = df['chunk_id'].unique()
    return [{'label': cid, 'value': cid} for cid in chunks]

# --- Main graph + stability tracking ---
@app.callback(
    [Output('recovery-graph', 'figure'),
     Output('stability-status', 'children'),
     Output('trend-graph', 'figure')],
    [Input('chunk-select', 'value'),
     Input('decay-slider', 'value'),
     Input('refresh-interval', 'n_intervals')]
)
def update_graph(chunk_id, decay_rate, _):
    if not chunk_id:
        return go.Figure(), "Select a chunk to monitor.", go.Figure()

    df = load_scheduler_data()
    df_chunk = df[df['chunk_id'] == chunk_id].sort_values('timestamp')

    if df_chunk.empty:
        return go.Figure(), "Awaiting live data...", go.Figure()

    t = np.linspace(0, len(df_chunk), len(df_chunk))
    theoretical = compute_pi_star_recovery(t, decay_rate)
    actual = df_chunk['score'].values[:len(theoretical)]

    deviation = np.mean(np.abs(actual - theoretical))
    stability_state = classify_stability(deviation)

    # --- Save stability record ---
    log = load_stability_log()
    now = datetime.utcnow().isoformat()
    if chunk_id not in log:
        log[chunk_id] = []
    log[chunk_id].append({'time': now, 'deviation': deviation})
    log[chunk_id] = log[chunk_id][-MAX_HISTORY:]
    save_stability_log(log)

    # --- Auto-tuning hook ---
    if len(log[chunk_id]) >= 3 and all(e['deviation'] > 0.15 for e in log[chunk_id][-3:]):
        log[chunk_id][-1]['adjust'] = True
        save_stability_log(log)

    # --- Main recovery figure ---
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=t, y=theoretical, mode='lines', name='Ï€*-Model', line=dict(width=3, dash='dash', color='lightblue')))
    fig.add_trace(go.Scatter(x=t, y=actual, mode='lines+markers', name='Live Data', line=dict(width=2, color='orange')))
    fig.update_layout(template='plotly_dark', title=f'Chunk {chunk_id} | {stability_state}', xaxis_title='Time', yaxis_title='Priority', yaxis=dict(range=[0,1.1]))

    # --- Stability trendline ---
    log_df = pd.DataFrame(log.get(chunk_id, []))
    trend_fig = go.Figure()
    if not log_df.empty:
        trend_fig.add_trace(go.Scatter(
            x=log_df['time'], y=log_df['deviation'],
            mode='lines+markers', line=dict(color='cyan', width=2),
            name='Deviation History'
        ))
        trend_fig.update_layout(template='plotly_dark', title="Stability Trend", yaxis_title='Deviation Ratio')

    return fig, f"Current Stability: {stability_state} (Deviation={deviation:.3f})", trend_fig

# --- Export button ---
@app.callback(Output('download-log', 'data'), Input('export-btn', 'n_clicks'))
def export_log(n_clicks):
    if n_clicks == 0:
        return dash.no_update
    log = load_stability_log()
    rows = []
    for chunk_id, entries in log.items():
        for e in entries:
            rows.append({'chunk_id': chunk_id, **e})
    df = pd.DataFrame(rows)
    return dcc.send_data_frame(df.to_csv, "synara_stability_log.csv")

if __name__ == '__main__':
    app.run_server(debug=True)